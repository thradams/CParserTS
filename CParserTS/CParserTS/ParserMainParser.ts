/*
 * Generated by TKLGEN - VersionJun 22 2016
 * Copyright (C) 2013, Thiago Adams (thiago.adams@gmail.com)
 * www.thradams.com
 *
 */

function Parse_Declaration(ctx : Parser) : Result
{
    var result = RESULT_OK;
    var token = Token(ctx); 

    if (token == Tokens.TK_identifier ||
        token == Tokens.TK_short ||
        token == Tokens.TK_double ||
        token == Tokens.TK_static ||
        token == Tokens.TK_auto ||
        token == Tokens.TK_register ||
        token == Tokens.TK_typedef ||
        token == Tokens.TK_void ||
        token == Tokens.TK_float ||
        token == Tokens.TK_extern ||
        token == Tokens.TK_int ||
        token == Tokens.TK__Thread_local ||
        token == Tokens.TK_char ||
        token == Tokens.TK_long ||
        token == Tokens.TK__Bool ||
        token == Tokens.TK_signed ||
        token == Tokens.TK__Atomic ||
        token == Tokens.TK_unsigned ||
        token == Tokens.TK__Complex ||
        token == Tokens.TK_const ||
        token == Tokens.TK_restrict ||
        token == Tokens.TK_volatile ||
        token == Tokens.TK_enum ||
        token == Tokens.TK_inline ||
        token == Tokens.TK__Noreturn ||
        token == Tokens.TK_struct ||
        token == Tokens.TK__Alignas ||
        token == Tokens.TK_union)
    {
        /*Declaration => Declaration_Specifiers Init_Declarator_List_Opt SEMICOLON */
        if (Check(result)) result = Parse_Declaration_Specifiers(ctx);
        if (Check(result)) result = Parse_Init_Declarator_List_Opt(ctx);
        if (Check(result)) result = Match(ctx, Tokens.TK_SEMICOLON);
    }
    else if (token == Tokens.TK__Static_assert)
    {
        /*Declaration => Static_Assert_Declaration */
        if (Check(result)) result = Parse_Static_Assert_Declaration(ctx);
    }
    else
    {
        result = RESULT_FAIL;
    }

    return result;
}

function Parse_Enumeration_Constant(ctx : Parser) : Result
{
    var result = RESULT_OK;
    var token = Token(ctx); 

    if (token == Tokens.TK_identifier)
    {
        /*Enumeration_Constant => identifier */
        if (Check(result)) result = Match(ctx, Tokens.TK_identifier);
    }
    else
    {
        result = RESULT_FAIL;
    }

    return result;
}

function Parse_Function_Specifier(ctx : Parser) : Result
{
    var result = RESULT_OK;
    var token = Token(ctx); 

    if (token == Tokens.TK_inline)
    {
        /*Function_Specifier => inline */
        if (Check(result)) result = Match(ctx, Tokens.TK_inline);
    }
    else if (token == Tokens.TK__Noreturn)
    {
        /*Function_Specifier => _Noreturn */
        if (Check(result)) result = Match(ctx, Tokens.TK__Noreturn);
    }
    else
    {
        result = RESULT_FAIL;
    }

    return result;
}

function Parse_Storage_Class_Specifier(ctx : Parser) : Result
{
    var result = RESULT_OK;
    var token = Token(ctx); 

    if (token == Tokens.TK_typedef)
    {
        /*Storage_Class_Specifier => typedef */
        if (Check(result)) result = Match(ctx, Tokens.TK_typedef);
    }
    else if (token == Tokens.TK_extern)
    {
        /*Storage_Class_Specifier => extern */
        if (Check(result)) result = Match(ctx, Tokens.TK_extern);
    }
    else if (token == Tokens.TK_static)
    {
        /*Storage_Class_Specifier => static */
        if (Check(result)) result = Match(ctx, Tokens.TK_static);
    }
    else if (token == Tokens.TK__Thread_local)
    {
        /*Storage_Class_Specifier => _Thread_local */
        if (Check(result)) result = Match(ctx, Tokens.TK__Thread_local);
    }
    else if (token == Tokens.TK_auto)
    {
        /*Storage_Class_Specifier => auto */
        if (Check(result)) result = Match(ctx, Tokens.TK_auto);
    }
    else if (token == Tokens.TK_register)
    {
        /*Storage_Class_Specifier => register */
        if (Check(result)) result = Match(ctx, Tokens.TK_register);
    }
    else
    {
        result = RESULT_FAIL;
    }

    return result;
}

function Parse_Alignment_Specifier(ctx : Parser) : Result
{
    var result = RESULT_OK;
    var token = Token(ctx); 

    if (token == Tokens.TK__Alignas)
    {
        /*Alignment_Specifier => _Alignas LEFT_PARENTHESIS Type_Name RIGHT_PARENTHESIS */
        if (Check(result)) result = Match(ctx, Tokens.TK__Alignas);
        if (Check(result)) result = Match(ctx, Tokens.TK_LEFT_PARENTHESIS);
        if (Check(result)) result = Parse_Type_Name(ctx);
        if (Check(result)) result = Match(ctx, Tokens.TK_RIGHT_PARENTHESIS);
    }
    else if (token == Tokens.TK__Alignas)
    {
        /*Alignment_Specifier => _Alignas LEFT_PARENTHESIS Constant_Expression RIGHT_PARENTHESIS */
        if (Check(result)) result = Match(ctx, Tokens.TK__Alignas);
        if (Check(result)) result = Match(ctx, Tokens.TK_LEFT_PARENTHESIS);
        if (Check(result)) result = Parse_Constant_Expression(ctx);
        if (Check(result)) result = Match(ctx, Tokens.TK_RIGHT_PARENTHESIS);
    }
    else
    {
        result = RESULT_FAIL;
    }

    return result;
}

function Parse_Type_Specifier(ctx : Parser) : Result
{
    var result = RESULT_OK;
    var token = Token(ctx); 

    if (token == Tokens.TK_void)
    {
        /*Type_Specifier => void */
        if (Check(result)) result = Match(ctx, Tokens.TK_void);
    }
    else if (token == Tokens.TK_char)
    {
        /*Type_Specifier => char */
        if (Check(result)) result = Match(ctx, Tokens.TK_char);
    }
    else if (token == Tokens.TK_short)
    {
        /*Type_Specifier => short */
        if (Check(result)) result = Match(ctx, Tokens.TK_short);
    }
    else if (token == Tokens.TK_int)
    {
        /*Type_Specifier => int */
        if (Check(result)) result = Match(ctx, Tokens.TK_int);
    }
    else if (token == Tokens.TK_long)
    {
        /*Type_Specifier => long */
        if (Check(result)) result = Match(ctx, Tokens.TK_long);
    }
    else if (token == Tokens.TK_float)
    {
        /*Type_Specifier => float */
        if (Check(result)) result = Match(ctx, Tokens.TK_float);
    }
    else if (token == Tokens.TK_double)
    {
        /*Type_Specifier => double */
        if (Check(result)) result = Match(ctx, Tokens.TK_double);
    }
    else if (token == Tokens.TK_signed)
    {
        /*Type_Specifier => signed */
        if (Check(result)) result = Match(ctx, Tokens.TK_signed);
    }
    else if (token == Tokens.TK_unsigned)
    {
        /*Type_Specifier => unsigned */
        if (Check(result)) result = Match(ctx, Tokens.TK_unsigned);
    }
    else if (token == Tokens.TK__Bool)
    {
        /*Type_Specifier => _Bool */
        if (Check(result)) result = Match(ctx, Tokens.TK__Bool);
    }
    else if (token == Tokens.TK__Complex)
    {
        /*Type_Specifier => _Complex */
        if (Check(result)) result = Match(ctx, Tokens.TK__Complex);
    }
    else if (token == Tokens.TK__Atomic)
    {
        /*Type_Specifier => Atomic_Type_Specifier */
        if (Check(result)) result = Parse_Atomic_Type_Specifier(ctx);
    }
    else if (token == Tokens.TK_struct ||
        token == Tokens.TK_union)
    {
        /*Type_Specifier => Struct_Or_Union_Specifier */
        if (Check(result)) result = Parse_Struct_Or_Union_Specifier(ctx);
    }
    else if (token == Tokens.TK_enum)
    {
        /*Type_Specifier => Enum_Specifier */
        if (Check(result)) result = Parse_Enum_Specifier(ctx);
    }
    else if (token == Tokens.TK_identifier)
    {
        /*Type_Specifier => Typedef_Name */
        if (Check(result)) result = Parse_Typedef_Name(ctx);
    }
    else
    {
        result = RESULT_FAIL;
    }

    return result;
}

function Parse_Declaration_Specifiers(ctx : Parser) : Result
{
    var result = RESULT_OK;
    var token = Token(ctx); 

    if (token == Tokens.TK_static ||
        token == Tokens.TK_auto ||
        token == Tokens.TK_register ||
        token == Tokens.TK_typedef ||
        token == Tokens.TK_extern ||
        token == Tokens.TK__Thread_local)
    {
        /*Declaration_Specifiers => Storage_Class_Specifier Declaration_SpecifiersOpt */
        if (Check(result)) result = Parse_Storage_Class_Specifier(ctx);
        if (Check(result)) result = Parse_Declaration_SpecifiersOpt(ctx);
    }
    else if (token == Tokens.TK_identifier ||
        token == Tokens.TK_short ||
        token == Tokens.TK_double ||
        token == Tokens.TK_void ||
        token == Tokens.TK_float ||
        token == Tokens.TK_int ||
        token == Tokens.TK_char ||
        token == Tokens.TK_long ||
        token == Tokens.TK__Bool ||
        token == Tokens.TK_signed ||
        token == Tokens.TK__Atomic ||
        token == Tokens.TK_unsigned ||
        token == Tokens.TK__Complex ||
        token == Tokens.TK_enum ||
        token == Tokens.TK_struct ||
        token == Tokens.TK_union)
    {
        /*Declaration_Specifiers => Type_Specifier Declaration_SpecifiersOpt */
        if (Check(result)) result = Parse_Type_Specifier(ctx);
        if (Check(result)) result = Parse_Declaration_SpecifiersOpt(ctx);
    }
    else if (token == Tokens.TK__Atomic ||
        token == Tokens.TK_const ||
        token == Tokens.TK_restrict ||
        token == Tokens.TK_volatile)
    {
        /*Declaration_Specifiers => Type_Qualifier Declaration_SpecifiersOpt */
        if (Check(result)) result = Parse_Type_Qualifier(ctx);
        if (Check(result)) result = Parse_Declaration_SpecifiersOpt(ctx);
    }
    else if (token == Tokens.TK_inline ||
        token == Tokens.TK__Noreturn)
    {
        /*Declaration_Specifiers => Function_Specifier Declaration_SpecifiersOpt */
        if (Check(result)) result = Parse_Function_Specifier(ctx);
        if (Check(result)) result = Parse_Declaration_SpecifiersOpt(ctx);
    }
    else if (token == Tokens.TK__Alignas)
    {
        /*Declaration_Specifiers => Alignment_Specifier Declaration_SpecifiersOpt */
        if (Check(result)) result = Parse_Alignment_Specifier(ctx);
        if (Check(result)) result = Parse_Declaration_SpecifiersOpt(ctx);
    }
    else
    {
        result = RESULT_FAIL;
    }

    return result;
}

function Parse_Static_Assert_Declaration(ctx : Parser) : Result
{
    var result = RESULT_OK;
    var token = Token(ctx); 

    if (token == Tokens.TK__Static_assert)
    {
        /*Static_Assert_Declaration => _Static_assert LEFT_PARENTHESIS Constant_Expression COMMA string_literal RIGHT_PARENTHESIS SEMICOLON */
        if (Check(result)) result = Match(ctx, Tokens.TK__Static_assert);
        if (Check(result)) result = Match(ctx, Tokens.TK_LEFT_PARENTHESIS);
        if (Check(result)) result = Parse_Constant_Expression(ctx);
        if (Check(result)) result = Match(ctx, Tokens.TK_COMMA);
        if (Check(result)) result = Match(ctx, Tokens.TK_string_literal);
        if (Check(result)) result = Match(ctx, Tokens.TK_RIGHT_PARENTHESIS);
        if (Check(result)) result = Match(ctx, Tokens.TK_SEMICOLON);
    }
    else
    {
        result = RESULT_FAIL;
    }

    return result;
}

function Parse_Declaration_SpecifiersOpt(ctx : Parser) : Result
{
    var result = RESULT_OK;
    var token = Token(ctx); 

    if (token == Tokens.TK_identifier ||
        token == Tokens.TK_short ||
        token == Tokens.TK_double ||
        token == Tokens.TK_static ||
        token == Tokens.TK_auto ||
        token == Tokens.TK_register ||
        token == Tokens.TK_typedef ||
        token == Tokens.TK_void ||
        token == Tokens.TK_float ||
        token == Tokens.TK_extern ||
        token == Tokens.TK_int ||
        token == Tokens.TK__Thread_local ||
        token == Tokens.TK_char ||
        token == Tokens.TK_long ||
        token == Tokens.TK__Bool ||
        token == Tokens.TK_signed ||
        token == Tokens.TK__Atomic ||
        token == Tokens.TK_unsigned ||
        token == Tokens.TK__Complex ||
        token == Tokens.TK_const ||
        token == Tokens.TK_restrict ||
        token == Tokens.TK_volatile ||
        token == Tokens.TK_enum ||
        token == Tokens.TK_inline ||
        token == Tokens.TK__Noreturn ||
        token == Tokens.TK_struct ||
        token == Tokens.TK__Alignas ||
        token == Tokens.TK_union)
    {
        /*Declaration_SpecifiersOpt => Declaration_Specifiers */
        if (Check(result)) result = Parse_Declaration_Specifiers(ctx);
    }
    else if (token == Tokens.TK_EndMark ||
        token == Tokens.TK_SEMICOLON)
    {
        /*Declaration_SpecifiersOpt => Epsilon */
        result = RESULT_EMPTY; /*opt*/
    }
    else
    {
        result = RESULT_FAIL;
    }

    return result;
}

function Parse_Type_Qualifier(ctx : Parser) : Result
{
    var result = RESULT_OK;
    var token = Token(ctx); 

    if (token == Tokens.TK_const)
    {
        /*Type_Qualifier => const */
        if (Check(result)) result = Match(ctx, Tokens.TK_const);
    }
    else if (token == Tokens.TK_restrict)
    {
        /*Type_Qualifier => restrict */
        if (Check(result)) result = Match(ctx, Tokens.TK_restrict);
    }
    else if (token == Tokens.TK_volatile)
    {
        /*Type_Qualifier => volatile */
        if (Check(result)) result = Match(ctx, Tokens.TK_volatile);
    }
    else if (token == Tokens.TK__Atomic)
    {
        /*Type_Qualifier => _Atomic */
        if (Check(result)) result = Match(ctx, Tokens.TK__Atomic);
    }
    else
    {
        result = RESULT_FAIL;
    }

    return result;
}

function Parse_Init_Declarator_List_Opt(ctx : Parser) : Result
{
    var result = RESULT_OK;
    var token = Token(ctx); 

    if (token == Tokens.TK_SEMICOLON)
    {
        /*Init_Declarator_List_Opt => Epsilon */
        result = RESULT_EMPTY; /*opt*/
    }
    else
    {
        result = RESULT_FAIL;
    }

    return result;
}

function Parse_Initializer_List(ctx : Parser) : Result
{
    var result = RESULT_OK;
    var token = Token(ctx); 

    if (token == Tokens.TK_RIGHT_CURLY_BRACKET ||
        token == Tokens.TK_COMMA)
    {
        /*Initializer_List => Epsilon */
        result = RESULT_EMPTY; /*opt*/
    }
    else
    {
        result = RESULT_FAIL;
    }

    return result;
}

function Parse_Initializer(ctx : Parser) : Result
{
    var result = RESULT_OK;
    var token = Token(ctx); 

    if (token == Tokens.TK_COMMA)
    {
        /*Initializer => Assignment_Expression */
        if (Check(result)) result = Parse_Assignment_Expression(ctx);
    }
    else if (token == Tokens.TK_LEFT_CURLY_BRACKET)
    {
        /*Initializer => LEFT_CURLY_BRACKET Initializer_List RIGHT_CURLY_BRACKET LEFT_CURLY_BRACKET Initializer_List COMMA RIGHT_CURLY_BRACKET SEMICOLON */
        if (Check(result)) result = Match(ctx, Tokens.TK_LEFT_CURLY_BRACKET);
        if (Check(result)) result = Parse_Initializer_List(ctx);
        if (Check(result)) result = Match(ctx, Tokens.TK_RIGHT_CURLY_BRACKET);
        if (Check(result)) result = Match(ctx, Tokens.TK_LEFT_CURLY_BRACKET);
        if (Check(result)) result = Parse_Initializer_List(ctx);
        if (Check(result)) result = Match(ctx, Tokens.TK_COMMA);
        if (Check(result)) result = Match(ctx, Tokens.TK_RIGHT_CURLY_BRACKET);
        if (Check(result)) result = Match(ctx, Tokens.TK_SEMICOLON);
    }
    else
    {
        result = RESULT_FAIL;
    }

    return result;
}

function Parse_Assignment_Expression(ctx : Parser) : Result
{
    var result = RESULT_OK;
    var token = Token(ctx); 

    if (token == Tokens.TK_COMMA ||
        token == Tokens.TK_RIGHT_SQUARE_BRACKET)
    {
        /*Assignment_Expression => Epsilon */
        result = RESULT_EMPTY; /*opt*/
    }
    else
    {
        result = RESULT_FAIL;
    }

    return result;
}

function Parse_Struct_Or_Union(ctx : Parser) : Result
{
    var result = RESULT_OK;
    var token = Token(ctx); 

    if (token == Tokens.TK_struct)
    {
        /*Struct_Or_Union => struct */
        if (Check(result)) result = Match(ctx, Tokens.TK_struct);
    }
    else if (token == Tokens.TK_union)
    {
        /*Struct_Or_Union => union */
        if (Check(result)) result = Match(ctx, Tokens.TK_union);
    }
    else
    {
        result = RESULT_FAIL;
    }

    return result;
}

function Parse_Struct_Or_Union_Specifier(ctx : Parser) : Result
{
    var result = RESULT_OK;
    var token = Token(ctx); 

    if (token == Tokens.TK_struct ||
        token == Tokens.TK_union)
    {
        /*Struct_Or_Union_Specifier => Struct_Or_Union IdentifierOpt LEFT_CURLY_BRACKET Struct_Declaration_List RIGHT_CURLY_BRACKET */
        if (Check(result)) result = Parse_Struct_Or_Union(ctx);
        if (Check(result)) result = Parse_IdentifierOpt(ctx);
        if (Check(result)) result = Match(ctx, Tokens.TK_LEFT_CURLY_BRACKET);
        if (Check(result)) result = Parse_Struct_Declaration_List(ctx);
        if (Check(result)) result = Match(ctx, Tokens.TK_RIGHT_CURLY_BRACKET);
    }
    else
    {
        result = RESULT_FAIL;
    }

    return result;
}

function Parse_IdentifierOpt(ctx : Parser) : Result
{
    var result = RESULT_OK;
    var token = Token(ctx); 

    if (token == Tokens.TK_identifier)
    {
        /*IdentifierOpt => identifier */
        if (Check(result)) result = Match(ctx, Tokens.TK_identifier);
    }
    else if (token == Tokens.TK_LEFT_CURLY_BRACKET)
    {
        /*IdentifierOpt => Epsilon */
        result = RESULT_EMPTY; /*opt*/
    }
    else
    {
        result = RESULT_FAIL;
    }

    return result;
}

function Parse_Enum_Specifier(ctx : Parser) : Result
{
    var result = RESULT_OK;
    var token = Token(ctx); 

    if (token == Tokens.TK_enum)
    {
        /*Enum_Specifier => enum IdentifierOpt LEFT_CURLY_BRACKET Enumerator_List RIGHT_CURLY_BRACKET */
        if (Check(result)) result = Match(ctx, Tokens.TK_enum);
        if (Check(result)) result = Parse_IdentifierOpt(ctx);
        if (Check(result)) result = Match(ctx, Tokens.TK_LEFT_CURLY_BRACKET);
        if (Check(result)) result = Parse_Enumerator_List(ctx);
        if (Check(result)) result = Match(ctx, Tokens.TK_RIGHT_CURLY_BRACKET);
    }
    else if (token == Tokens.TK_enum)
    {
        /*Enum_Specifier => enum IdentifierOpt LEFT_CURLY_BRACKET Enumerator_List COMMA RIGHT_CURLY_BRACKET */
        if (Check(result)) result = Match(ctx, Tokens.TK_enum);
        if (Check(result)) result = Parse_IdentifierOpt(ctx);
        if (Check(result)) result = Match(ctx, Tokens.TK_LEFT_CURLY_BRACKET);
        if (Check(result)) result = Parse_Enumerator_List(ctx);
        if (Check(result)) result = Match(ctx, Tokens.TK_COMMA);
        if (Check(result)) result = Match(ctx, Tokens.TK_RIGHT_CURLY_BRACKET);
    }
    else if (token == Tokens.TK_enum)
    {
        /*Enum_Specifier => enum identifier */
        if (Check(result)) result = Match(ctx, Tokens.TK_enum);
        if (Check(result)) result = Match(ctx, Tokens.TK_identifier);
    }
    else
    {
        result = RESULT_FAIL;
    }

    return result;
}

function Parse_Struct_Declarator_ListOpt(ctx : Parser) : Result
{
    var result = RESULT_OK;
    var token = Token(ctx); 

    if (token == Tokens.TK_identifier ||
        token == Tokens.TK_short ||
        token == Tokens.TK_double ||
        token == Tokens.TK_void ||
        token == Tokens.TK_float ||
        token == Tokens.TK_int ||
        token == Tokens.TK_char ||
        token == Tokens.TK_long ||
        token == Tokens.TK__Bool ||
        token == Tokens.TK_signed ||
        token == Tokens.TK__Atomic ||
        token == Tokens.TK_unsigned ||
        token == Tokens.TK__Complex ||
        token == Tokens.TK_const ||
        token == Tokens.TK_restrict ||
        token == Tokens.TK_volatile ||
        token == Tokens.TK__Static_assert ||
        token == Tokens.TK_enum ||
        token == Tokens.TK_struct ||
        token == Tokens.TK_union)
    {
        /*Struct_Declarator_ListOpt => Struct_Declaration_List */
        if (Check(result)) result = Parse_Struct_Declaration_List(ctx);
    }
    else if (token == Tokens.TK_identifier ||
        token == Tokens.TK_short ||
        token == Tokens.TK_double ||
        token == Tokens.TK_void ||
        token == Tokens.TK_float ||
        token == Tokens.TK_int ||
        token == Tokens.TK_RIGHT_CURLY_BRACKET ||
        token == Tokens.TK_char ||
        token == Tokens.TK_long ||
        token == Tokens.TK__Bool ||
        token == Tokens.TK_signed ||
        token == Tokens.TK__Atomic ||
        token == Tokens.TK_unsigned ||
        token == Tokens.TK__Complex ||
        token == Tokens.TK_const ||
        token == Tokens.TK_restrict ||
        token == Tokens.TK_volatile ||
        token == Tokens.TK__Static_assert ||
        token == Tokens.TK_enum ||
        token == Tokens.TK_struct ||
        token == Tokens.TK_union)
    {
        /*Struct_Declarator_ListOpt => Epsilon */
        result = RESULT_EMPTY; /*opt*/
    }
    else
    {
        result = RESULT_FAIL;
    }

    return result;
}

function Parse_Specifier_Qualifier_List(ctx : Parser) : Result
{
    var result = RESULT_OK;
    var token = Token(ctx); 

    if (token == Tokens.TK_identifier ||
        token == Tokens.TK_short ||
        token == Tokens.TK_double ||
        token == Tokens.TK_void ||
        token == Tokens.TK_float ||
        token == Tokens.TK_int ||
        token == Tokens.TK_char ||
        token == Tokens.TK_long ||
        token == Tokens.TK__Bool ||
        token == Tokens.TK_signed ||
        token == Tokens.TK__Atomic ||
        token == Tokens.TK_unsigned ||
        token == Tokens.TK__Complex ||
        token == Tokens.TK_enum ||
        token == Tokens.TK_struct ||
        token == Tokens.TK_union)
    {
        /*Specifier_Qualifier_List => Type_Specifier Specifier_Qualifier_ListOpt */
        if (Check(result)) result = Parse_Type_Specifier(ctx);
        if (Check(result)) result = Parse_Specifier_Qualifier_ListOpt(ctx);
    }
    else if (token == Tokens.TK__Atomic ||
        token == Tokens.TK_const ||
        token == Tokens.TK_restrict ||
        token == Tokens.TK_volatile)
    {
        /*Specifier_Qualifier_List => Type_Qualifier Specifier_Qualifier_ListOpt */
        if (Check(result)) result = Parse_Type_Qualifier(ctx);
        if (Check(result)) result = Parse_Specifier_Qualifier_ListOpt(ctx);
    }
    else
    {
        result = RESULT_FAIL;
    }

    return result;
}

function Parse_Type_Name(ctx : Parser) : Result
{
    var result = RESULT_OK;
    var token = Token(ctx); 

    if (token == Tokens.TK_identifier ||
        token == Tokens.TK_short ||
        token == Tokens.TK_double ||
        token == Tokens.TK_void ||
        token == Tokens.TK_float ||
        token == Tokens.TK_int ||
        token == Tokens.TK_char ||
        token == Tokens.TK_long ||
        token == Tokens.TK__Bool ||
        token == Tokens.TK_signed ||
        token == Tokens.TK__Atomic ||
        token == Tokens.TK_unsigned ||
        token == Tokens.TK__Complex ||
        token == Tokens.TK_const ||
        token == Tokens.TK_restrict ||
        token == Tokens.TK_volatile ||
        token == Tokens.TK_enum ||
        token == Tokens.TK_struct ||
        token == Tokens.TK_union)
    {
        /*Type_Name => Specifier_Qualifier_List Abstract_DeclaratorOpt */
        if (Check(result)) result = Parse_Specifier_Qualifier_List(ctx);
        if (Check(result)) result = Parse_Abstract_DeclaratorOpt(ctx);
    }
    else
    {
        result = RESULT_FAIL;
    }

    return result;
}

function Parse_Struct_Declaration(ctx : Parser) : Result
{
    var result = RESULT_OK;
    var token = Token(ctx); 

    if (token == Tokens.TK_identifier ||
        token == Tokens.TK_short ||
        token == Tokens.TK_double ||
        token == Tokens.TK_void ||
        token == Tokens.TK_float ||
        token == Tokens.TK_int ||
        token == Tokens.TK_char ||
        token == Tokens.TK_long ||
        token == Tokens.TK__Bool ||
        token == Tokens.TK_signed ||
        token == Tokens.TK__Atomic ||
        token == Tokens.TK_unsigned ||
        token == Tokens.TK__Complex ||
        token == Tokens.TK_const ||
        token == Tokens.TK_restrict ||
        token == Tokens.TK_volatile ||
        token == Tokens.TK_enum ||
        token == Tokens.TK_struct ||
        token == Tokens.TK_union)
    {
        /*Struct_Declaration => Specifier_Qualifier_List Struct_Declarator_ListOpt */
        if (Check(result)) result = Parse_Specifier_Qualifier_List(ctx);
        if (Check(result)) result = Parse_Struct_Declarator_ListOpt(ctx);
    }
    else if (token == Tokens.TK__Static_assert)
    {
        /*Struct_Declaration => Static_Assert_Declaration */
        if (Check(result)) result = Parse_Static_Assert_Declaration(ctx);
    }
    else
    {
        result = RESULT_FAIL;
    }

    return result;
}

function Parse_Typedef_Name(ctx : Parser) : Result
{
    var result = RESULT_OK;
    var token = Token(ctx); 

    if (token == Tokens.TK_identifier)
    {
        /*Typedef_Name => identifier */
        if (Check(result)) result = Match(ctx, Tokens.TK_identifier);
    }
    else
    {
        result = RESULT_FAIL;
    }

    return result;
}

function Parse_Atomic_Type_Specifier(ctx : Parser) : Result
{
    var result = RESULT_OK;
    var token = Token(ctx); 

    if (token == Tokens.TK__Atomic)
    {
        /*Atomic_Type_Specifier => _Atomic LEFT_PARENTHESIS Type_Name RIGHT_PARENTHESIS */
        if (Check(result)) result = Match(ctx, Tokens.TK__Atomic);
        if (Check(result)) result = Match(ctx, Tokens.TK_LEFT_PARENTHESIS);
        if (Check(result)) result = Parse_Type_Name(ctx);
        if (Check(result)) result = Match(ctx, Tokens.TK_RIGHT_PARENTHESIS);
    }
    else
    {
        result = RESULT_FAIL;
    }

    return result;
}

function Parse_Struct_Declaration_List(ctx : Parser) : Result
{
    var result = RESULT_OK;
    var token = Token(ctx); 

    if (token == Tokens.TK_identifier ||
        token == Tokens.TK_short ||
        token == Tokens.TK_double ||
        token == Tokens.TK_void ||
        token == Tokens.TK_float ||
        token == Tokens.TK_int ||
        token == Tokens.TK_char ||
        token == Tokens.TK_long ||
        token == Tokens.TK__Bool ||
        token == Tokens.TK_signed ||
        token == Tokens.TK__Atomic ||
        token == Tokens.TK_unsigned ||
        token == Tokens.TK__Complex ||
        token == Tokens.TK_const ||
        token == Tokens.TK_restrict ||
        token == Tokens.TK_volatile ||
        token == Tokens.TK__Static_assert ||
        token == Tokens.TK_enum ||
        token == Tokens.TK_struct ||
        token == Tokens.TK_union)
    {
        /*Struct_Declaration_List => Struct_Declaration */
        if (Check(result)) result = Parse_Struct_Declaration(ctx);
    }
    else if (token == Tokens.TK_identifier ||
        token == Tokens.TK_short ||
        token == Tokens.TK_double ||
        token == Tokens.TK_void ||
        token == Tokens.TK_float ||
        token == Tokens.TK_int ||
        token == Tokens.TK_char ||
        token == Tokens.TK_long ||
        token == Tokens.TK__Bool ||
        token == Tokens.TK_signed ||
        token == Tokens.TK__Atomic ||
        token == Tokens.TK_unsigned ||
        token == Tokens.TK__Complex ||
        token == Tokens.TK_const ||
        token == Tokens.TK_restrict ||
        token == Tokens.TK_volatile ||
        token == Tokens.TK__Static_assert ||
        token == Tokens.TK_enum ||
        token == Tokens.TK_struct ||
        token == Tokens.TK_union)
    {
        /*Struct_Declaration_List => Struct_Declaration_List Struct_Declaration */
        if (Check(result)) result = Parse_Struct_Declaration_List(ctx);
        if (Check(result)) result = Parse_Struct_Declaration(ctx);
    }
    else
    {
        result = RESULT_FAIL;
    }

    return result;
}

function Parse_Specifier_Qualifier_ListOpt(ctx : Parser) : Result
{
    var result = RESULT_OK;
    var token = Token(ctx); 

    if (token == Tokens.TK_identifier ||
        token == Tokens.TK_short ||
        token == Tokens.TK_double ||
        token == Tokens.TK_void ||
        token == Tokens.TK_float ||
        token == Tokens.TK_int ||
        token == Tokens.TK_char ||
        token == Tokens.TK_long ||
        token == Tokens.TK__Bool ||
        token == Tokens.TK_signed ||
        token == Tokens.TK__Atomic ||
        token == Tokens.TK_unsigned ||
        token == Tokens.TK__Complex ||
        token == Tokens.TK_const ||
        token == Tokens.TK_restrict ||
        token == Tokens.TK_volatile ||
        token == Tokens.TK_enum ||
        token == Tokens.TK_struct ||
        token == Tokens.TK_union)
    {
        /*Specifier_Qualifier_ListOpt => Specifier_Qualifier_List */
        if (Check(result)) result = Parse_Specifier_Qualifier_List(ctx);
    }
    else if (token == Tokens.TK_identifier ||
        token == Tokens.TK_short ||
        token == Tokens.TK_double ||
        token == Tokens.TK_void ||
        token == Tokens.TK_float ||
        token == Tokens.TK_int ||
        token == Tokens.TK_RIGHT_CURLY_BRACKET ||
        token == Tokens.TK_char ||
        token == Tokens.TK_long ||
        token == Tokens.TK_RIGHT_PARENTHESIS ||
        token == Tokens.TK_LEFT_PARENTHESIS ||
        token == Tokens.TK__Bool ||
        token == Tokens.TK_signed ||
        token == Tokens.TK__Atomic ||
        token == Tokens.TK_unsigned ||
        token == Tokens.TK__Complex ||
        token == Tokens.TK_const ||
        token == Tokens.TK_restrict ||
        token == Tokens.TK_volatile ||
        token == Tokens.TK__Static_assert ||
        token == Tokens.TK_enum ||
        token == Tokens.TK_ASTERISK ||
        token == Tokens.TK_struct ||
        token == Tokens.TK_union ||
        token == Tokens.TK_LEFT_SQUARE_BRACKET)
    {
        /*Specifier_Qualifier_ListOpt => Epsilon */
        result = RESULT_EMPTY; /*opt*/
    }
    else
    {
        result = RESULT_FAIL;
    }

    return result;
}

function Parse_Enumerator_List(ctx : Parser) : Result
{
    var result = RESULT_OK;
    var token = Token(ctx); 

    if (token == Tokens.TK_identifier)
    {
        /*Enumerator_List => Enumerator */
        if (Check(result)) result = Parse_Enumerator(ctx);
    }
    else
    {
        result = RESULT_FAIL;
    }

    return result;
}

function ParserMain_Main(ctx : Parser) : Result
{
    var result = RESULT_OK;
    var token = Token(ctx); 

    if (token == Tokens.TK_identifier ||
        token == Tokens.TK_short ||
        token == Tokens.TK_double ||
        token == Tokens.TK_static ||
        token == Tokens.TK_auto ||
        token == Tokens.TK_register ||
        token == Tokens.TK_typedef ||
        token == Tokens.TK_void ||
        token == Tokens.TK_float ||
        token == Tokens.TK_extern ||
        token == Tokens.TK_int ||
        token == Tokens.TK__Thread_local ||
        token == Tokens.TK_char ||
        token == Tokens.TK_long ||
        token == Tokens.TK__Bool ||
        token == Tokens.TK_signed ||
        token == Tokens.TK__Atomic ||
        token == Tokens.TK_unsigned ||
        token == Tokens.TK__Complex ||
        token == Tokens.TK_const ||
        token == Tokens.TK_restrict ||
        token == Tokens.TK_volatile ||
        token == Tokens.TK__Static_assert ||
        token == Tokens.TK_enum ||
        token == Tokens.TK_inline ||
        token == Tokens.TK__Noreturn ||
        token == Tokens.TK_struct ||
        token == Tokens.TK__Alignas ||
        token == Tokens.TK_union)
    {
        /*Main => Declaration */
        if (Check(result)) result = Parse_Declaration(ctx);
    }
    else
    {
        result = RESULT_FAIL;
    }

    return result;
}

function Parse_Constant_Expression(ctx : Parser) : Result
{
    var result = RESULT_OK;
    var token = Token(ctx); 

    if (token == Tokens.TK_RIGHT_CURLY_BRACKET ||
        token == Tokens.TK_COMMA ||
        token == Tokens.TK_RIGHT_PARENTHESIS)
    {
        /*Constant_Expression => Epsilon */
        result = RESULT_EMPTY; /*opt*/
    }
    else
    {
        result = RESULT_FAIL;
    }

    return result;
}

function Parse_Enumerator(ctx : Parser) : Result
{
    var result = RESULT_OK;
    var token = Token(ctx); 

    if (token == Tokens.TK_identifier)
    {
        /*Enumerator => Enumeration_Constant */
        if (Check(result)) result = Parse_Enumeration_Constant(ctx);
    }
    else if (token == Tokens.TK_identifier)
    {
        /*Enumerator => Enumeration_Constant EQUALS_SIGN Constant_Expression */
        if (Check(result)) result = Parse_Enumeration_Constant(ctx);
        if (Check(result)) result = Match(ctx, Tokens.TK_EQUALS_SIGN);
        if (Check(result)) result = Parse_Constant_Expression(ctx);
    }
    else
    {
        result = RESULT_FAIL;
    }

    return result;
}

function Parse_DeclaratorOpt(ctx : Parser) : Result
{
    var result = RESULT_OK;
    var token = Token(ctx); 

    if (token == Tokens.TK_COLON)
    {
        /*DeclaratorOpt => DeclaratorOpt */
        if (Check(result)) result = Parse_DeclaratorOpt(ctx);
    }
    else if (token == Tokens.TK_COLON)
    {
        /*DeclaratorOpt => Epsilon */
        result = RESULT_EMPTY; /*opt*/
    }
    else
    {
        result = RESULT_FAIL;
    }

    return result;
}

function Parse_Abstract_DeclaratorOpt(ctx : Parser) : Result
{
    var result = RESULT_OK;
    var token = Token(ctx); 

    if (token == Tokens.TK_RIGHT_PARENTHESIS ||
        token == Tokens.TK_LEFT_PARENTHESIS ||
        token == Tokens.TK_ASTERISK ||
        token == Tokens.TK_LEFT_SQUARE_BRACKET)
    {
        /*Abstract_DeclaratorOpt => Abstract_Declarator */
        if (Check(result)) result = Parse_Abstract_Declarator(ctx);
    }
    else if (token == Tokens.TK_RIGHT_PARENTHESIS)
    {
        /*Abstract_DeclaratorOpt => Epsilon */
        result = RESULT_EMPTY; /*opt*/
    }
    else
    {
        result = RESULT_FAIL;
    }

    return result;
}

function Parse_Pointer(ctx : Parser) : Result
{
    var result = RESULT_OK;
    var token = Token(ctx); 

    if (token == Tokens.TK_ASTERISK)
    {
        /*Pointer => ASTERISK Type_Qualifier_ListOpt */
        if (Check(result)) result = Match(ctx, Tokens.TK_ASTERISK);
        if (Check(result)) result = Parse_Type_Qualifier_ListOpt(ctx);
    }
    else if (token == Tokens.TK_ASTERISK)
    {
        /*Pointer => ASTERISK Type_Qualifier_ListOpt Pointer */
        if (Check(result)) result = Match(ctx, Tokens.TK_ASTERISK);
        if (Check(result)) result = Parse_Type_Qualifier_ListOpt(ctx);
        if (Check(result)) result = Parse_Pointer(ctx);
    }
    else
    {
        result = RESULT_FAIL;
    }

    return result;
}

function Parse_Abstract_Declarator(ctx : Parser) : Result
{
    var result = RESULT_OK;
    var token = Token(ctx); 

    if (token == Tokens.TK_ASTERISK)
    {
        /*Abstract_Declarator => Pointer */
        if (Check(result)) result = Parse_Pointer(ctx);
    }
    else if (token == Tokens.TK_RIGHT_PARENTHESIS ||
        token == Tokens.TK_LEFT_PARENTHESIS ||
        token == Tokens.TK_ASTERISK ||
        token == Tokens.TK_LEFT_SQUARE_BRACKET)
    {
        /*Abstract_Declarator => PointerOpt Direct_Abstract_Declarator */
        if (Check(result)) result = Parse_PointerOpt(ctx);
        if (Check(result)) result = Parse_Direct_Abstract_Declarator(ctx);
    }
    else
    {
        result = RESULT_FAIL;
    }

    return result;
}

function Parse_Type_Qualifier_List(ctx : Parser) : Result
{
    var result = RESULT_OK;
    var token = Token(ctx); 

    if (token == Tokens.TK__Atomic ||
        token == Tokens.TK_const ||
        token == Tokens.TK_restrict ||
        token == Tokens.TK_volatile)
    {
        /*Type_Qualifier_List => Type_Qualifier */
        if (Check(result)) result = Parse_Type_Qualifier(ctx);
    }
    else if (token == Tokens.TK__Atomic ||
        token == Tokens.TK_const ||
        token == Tokens.TK_restrict ||
        token == Tokens.TK_volatile)
    {
        /*Type_Qualifier_List => Type_Qualifier_List Type_Qualifier */
        if (Check(result)) result = Parse_Type_Qualifier_List(ctx);
        if (Check(result)) result = Parse_Type_Qualifier(ctx);
    }
    else
    {
        result = RESULT_FAIL;
    }

    return result;
}

function Parse_Direct_Abstract_Declarator(ctx : Parser) : Result
{
    var result = RESULT_OK;
    var token = Token(ctx); 

    if (token == Tokens.TK_LEFT_PARENTHESIS)
    {
        /*Direct_Abstract_Declarator => LEFT_PARENTHESIS Abstract_Declarator RIGHT_PARENTHESIS */
        if (Check(result)) result = Match(ctx, Tokens.TK_LEFT_PARENTHESIS);
        if (Check(result)) result = Parse_Abstract_Declarator(ctx);
        if (Check(result)) result = Match(ctx, Tokens.TK_RIGHT_PARENTHESIS);
    }
    else if (token == Tokens.TK_LEFT_SQUARE_BRACKET)
    {
        /*Direct_Abstract_Declarator => LEFT_SQUARE_BRACKET Type_Qualifier_ListOpt Assignment_ExpressionOpt RIGHT_SQUARE_BRACKET */
        if (Check(result)) result = Match(ctx, Tokens.TK_LEFT_SQUARE_BRACKET);
        if (Check(result)) result = Parse_Type_Qualifier_ListOpt(ctx);
        if (Check(result)) result = Parse_Assignment_ExpressionOpt(ctx);
        if (Check(result)) result = Match(ctx, Tokens.TK_RIGHT_SQUARE_BRACKET);
    }
    else
    {
        result = RESULT_FAIL;
    }

    return result;
}

function Parse_PointerOpt(ctx : Parser) : Result
{
    var result = RESULT_OK;
    var token = Token(ctx); 

    if (token == Tokens.TK_ASTERISK)
    {
        /*PointerOpt => Pointer */
        if (Check(result)) result = Parse_Pointer(ctx);
    }
    else if (token == Tokens.TK_LEFT_PARENTHESIS ||
        token == Tokens.TK_LEFT_SQUARE_BRACKET)
    {
        /*PointerOpt => Epsilon */
        result = RESULT_EMPTY; /*opt*/
    }
    else
    {
        result = RESULT_FAIL;
    }

    return result;
}

function Parse_Type_Qualifier_ListOpt(ctx : Parser) : Result
{
    var result = RESULT_OK;
    var token = Token(ctx); 

    if (token == Tokens.TK__Atomic ||
        token == Tokens.TK_const ||
        token == Tokens.TK_restrict ||
        token == Tokens.TK_volatile)
    {
        /*Type_Qualifier_ListOpt => Type_Qualifier_List */
        if (Check(result)) result = Parse_Type_Qualifier_List(ctx);
    }
    else if (token == Tokens.TK_RIGHT_PARENTHESIS ||
        token == Tokens.TK_LEFT_PARENTHESIS ||
        token == Tokens.TK_ASTERISK ||
        token == Tokens.TK_RIGHT_SQUARE_BRACKET ||
        token == Tokens.TK_LEFT_SQUARE_BRACKET)
    {
        /*Type_Qualifier_ListOpt => Epsilon */
        result = RESULT_EMPTY; /*opt*/
    }
    else
    {
        result = RESULT_FAIL;
    }

    return result;
}

function Parse_Assignment_ExpressionOpt(ctx : Parser) : Result
{
    var result = RESULT_OK;
    var token = Token(ctx); 

    if (token == Tokens.TK_RIGHT_SQUARE_BRACKET)
    {
        /*Assignment_ExpressionOpt => Assignment_Expression */
        if (Check(result)) result = Parse_Assignment_Expression(ctx);
    }
    else if (token == Tokens.TK_RIGHT_SQUARE_BRACKET)
    {
        /*Assignment_ExpressionOpt => Epsilon */
        result = RESULT_EMPTY; /*opt*/
    }
    else
    {
        result = RESULT_FAIL;
    }

    return result;
}

